#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <time.h>
#include <sys/wait.h>
#include <errno.h>
#include <semaphore.h>


#define SHM_NAME "/cinta_transportadora"
#define TAM_MEM sizeof(char) * 2

int main(int argc, char *argv[]){
  // 1. Verificación de que si se pasen 2 argumentos
  if (argc != 2) {
    errno= EINVAL;
    perror("Error: se debe pasar un número par");
    return 1;
  }


  int fd[2];
  char *conjunto[] = {"AB", "AC", "BC"};
  const char *nomsemp = "/SEMP";

  // Definición de los semáforos
  sem_unlink("/SEMP");   // Borra cualquier rastro previo
  sem_t *semp = sem_open(nomsemp, O_CREAT, 0666, 1);
  if (semp == SEM_FAILED) {
    perror("Error al crear semáforo del productor");
    exit(1);
}

  sem_unlink("/SEMR2");   // Borra cualquier rastro previo
  sem_t *semr2 = sem_open("/SEMR2", O_CREAT, 0666, 0);
  if (semr2 == SEM_FAILED) {
    perror("Error al crear semáforo de robot 2");
    exit(1);
}

  sem_unlink("/SEMR3");
  sem_t *semr3 = sem_open("/SEMR3", O_CREAT, 0666, 0);
  if (semr3 == SEM_FAILED) {
    perror("Error al crear semáforo de robot 3");
    exit(1);
}

  sem_unlink("/SEMR1");
  sem_t *semr1 = sem_open("/SEMR1", O_CREAT, 0666, 0);
  if (semr1 == SEM_FAILED ) {
    perror("Error al crear semáforo de robot 1");
    exit(1);
}
  //  Crear memoria compartida
  int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
  if (shm_fd == -1) {
      perror("Error al crear memoria compartida");
      return 2;
  }

  // Ajustar tamaño de la memoria
  if (ftruncate(shm_fd, TAM_MEM) == -1) {
      perror("Error al configurar tamaño de memoria");
      return 3;
  }

  char *cinta = mmap(NULL, TAM_MEM, PROT_READ | PROT_WRITE,   MAP_SHARED, shm_fd, 0);
  if (cinta == MAP_FAILED) {
      perror("Error al mapear memoria");
      return 4;
  }

  // Crear el pipe de comunicación fábica-productor

  int pipefd[2];
  if (pipe(pipefd) <0) {
    perror("Error al crear la tubería");
    exit(1);
}

  pid_t pid = fork();


  if(pid < 0){
    perror("Error al crear proceso\n");
    return 3;
  }
  else if(pid == 0){
    // Tubería
    close(pipefd[1]);

    int N;

    // Leer N
    if (read(pipefd[0], &N, sizeof(int)) != sizeof(int)) {
      perror("Error leyendo N desde la tubería");
      exit(1);
      }


    close(pipefd[0]);  // Cerrar el extremo de lectura

    printf("Proceso productor: N = %d\n", N);


    for (int i = 0; i < N; i++) {
      const char *producto = conjunto[rand() % 3];
      sem_wait(semp);
      strncpy(cinta, producto, 2);  // Escribe en memoria compartida
      printf("Producido: %s\n", producto);

   // Verificación de cual robot le corresponde para despertarlo
      if (strcmp(producto, "AB") == 0)
        sem_post(semr1);

      else if (strcmp(producto, "AC") == 0)
        sem_post(semr2);

      else
	sem_post(semr3);
    }
      sem_wait(semp);
      strncpy(cinta, "ZZ", 2); //Finalizado
      printf("Producido: ZZ\n");
      fflush(stdout);


        // Despertar a todos para que se cierren
    sem_post(semr1);
    sem_post(semr2);
    sem_post(semr3);


  } else {

	// Cierre del extremo de lectura
      close(pipefd[0]);
      int N = atoi(argv[1]);

      // 2. Verificación que el número sea par
      if (N <=0 || N%2 != 0) {
        errno= EINVAL;
        perror("Error, el número debe ser par");
        return 1;
 }

    // Escribir N
      if (write(pipefd[1], &N, sizeof(int)) != sizeof(int)) {
        perror("Error escribiendo N en la tubería");
        exit(1);
    }

      close(pipefd[1]);
      //Padre
      wait(NULL);
      // Liberar recursos
      sem_close(semp); sem_unlink("/SEMP");
      sem_close(semr1); sem_unlink("/SEMR1");
      sem_close(semr2); sem_unlink("/SEMR2");
      sem_close(semr3); sem_unlink("/SEMR3");
      munmap(cinta, TAM_MEM);
      close(shm_fd);
      shm_unlink(SHM_NAME);
  }

  return 0;
}


